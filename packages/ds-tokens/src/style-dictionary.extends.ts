
import StyleDictionary, { TransformedToken, TransformedTokens } from "style-dictionary";
import { transformTypes } from "style-dictionary/enums";
import JsonToTS from 'json-to-ts';


const autogeneratedHeader = `/** 
 * Do not edit directly
 * Generated by Style Dictionary
 */
`;

StyleDictionary.registerTransform({
    type: transformTypes.value,
    name: "value/px-for-number",
    filter: (token, options) => {
        const isPx = [
            'font-size',
            'number-spacing',
            'number-screen',
            'number-width',
            'number-radius',
            'number-blur'
        ].some(s => token.name.includes(s));

        return isPx
    },
    transform: (token) => {
        return `${token.value}px`;
    },
});

const kebabToPascal = (str: string) => {
    return str
        .split('-')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join('');
}

const tokenToCssVarname = (t: TransformedToken) => {
    return `--${t.key?.replaceAll('.', '-').replaceAll('{', '').replaceAll('}', '')}`
}

StyleDictionary.registerFormat({
    name: "typescript/declarations",
    format: ({ dictionary, ...rest }) => {
        const destination = rest.file?.destination || 'variables.types.ts';
        const typeName = rest?.options?.typeName || kebabToPascal(destination.split('.')[0]);
        const vars = dictionary.allTokens
            .map((t) => `'${tokenToCssVarname(t)}'`)
            .join(" | ");

        return `${autogeneratedHeader}
declare module 'css-variables' {
  export type CssVar${typeName} = ${vars};
}
`;
    },
});

StyleDictionary.registerFormat({
    name: "json/css-variables-list",
    format: ({ dictionary }) => {
        const vars = dictionary.allTokens.map(t => tokenToCssVarname(t));
        return JSON.stringify(vars, null, 2);
    }
});

function buildNestedObject(tokens: TransformedToken[]) {
    const result: Record<string, any> = {};

    for (const token of tokens) {
        let current = result;

        token.path.forEach((part, idx) => {
            if (idx === token.path.length - 1) {
                current[part] = token.value;
            } else {
                current[part] = current[part] || {};
                current = current[part];
            }
        });
    }

    return result;
}


StyleDictionary.registerFormat({
    name: 'javascript/dictionnary-object-const',
    format: function ({ dictionary }) {
        const tokenObjects = buildNestedObject(dictionary.allTokens);
        return (
            'export default ' +
            JSON.stringify(tokenObjects, null, 2) +
            ';\n'
        );
    },
});
StyleDictionary.registerFormat({
    name: 'typescript/dictionnary-object-const-def',
    format: function ({ dictionary }) {
        const tokenObjects = buildNestedObject(dictionary.allTokens);
        return (
            'declare const root: RootObject\n' +
            'export default root\n' +
            JsonToTS.default(tokenObjects).join('\n')
        );
    },
});